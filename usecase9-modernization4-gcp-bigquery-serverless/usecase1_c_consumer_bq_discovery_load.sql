create schema if not exists discoveryds options(location='us-central1');

create table if not exists discoveryds.consumer_trans_pos_mob_online 
(txnno numeric,txndt date,custno int64,fullname string,age int64,profession string,trans_day string,trans_type string,net string,online_pos_amount float64,geo_coordinate geography,provider string,activity string,spendby string,city string,state string,online_pos_category string,product string,loadts timestamp,loaddt date);

--Data Wrangling - Joining and widening of the data and denormalization
--with clause query we call it as CTE - Common Table Expression
--Queries looks simple (since we are writing once) for both writing and reading
--Though it is same Query, it will run one time and loaded to memory and referenced multiple times
--enrichment, coverage of data (to avoid nulls), stitching of events generated by consumers accross multiple channels
--good for small volume of data
--by joining we are standardizing, wide table creation

insert into discoveryds.consumer_trans_pos_mob_online 

with 
pos_mob_trans as (select mob.txnno as mob_txnno,pos.txnno as pos_txnno,
case when mob.dt=pos.txndt then 'Same Day Trans' 
else 'Multi Day Trans' end as trans_day,
coalesce(mob.dt,pos.txndt) as txndt,
case when mob.txnno is null then 'POS'
when pos.txnno is null then 'MOB'
else 'POS_MOB' end as trans_type,
mob.net,
pos.amount,
mob.geo_coordinate,
mob.provider,
case when mob.activity='STILL' then 'In Store Pickup' else mob.activity end as activity,
pos.spendby,pos.city,pos.state,
pos.product,pos.category,
pos.loadts pos_loadts,pos.loaddt pos_loaddt,mob.loadts mob_loadts,mob.loaddt mob_loaddt,pos.custno
from `curatedds.trans_mobile_autopart_20*` mob 
full join `curatedds.trans_pos_part_cluster` pos
on mob.txnno=pos.txnno ),

cust_online_trans as (select *,case when transsk is not null then 'online' else null end as trans_type 
from `curatedds.consumer_full_load` cust 
left join `curatedds.trans_online_part` trans
on cust.custno=trans.customerid)

select coalesce(mob_txnno,pos_txnno) txnno,trans.txndt,trans.custno,fullname,age,profession,trans_day,coalesce(cust.trans_type,trans.trans_type) trans_type,coalesce(net,'na') net,coalesce(productprice,coalesce(amount,0.0)) online_pos_amount,geo_coordinate,coalesce(provider,'na') provider,coalesce(activity,'na') activity, coalesce(spendby,'na') spendby, coalesce(city,'unknown') city, coalesce(state,'unknown') state,coalesce(productcategory,category) online_pos_category,product,coalesce(pos_loadts,mob_loadts) loadts,coalesce(pos_loaddt,mob_loaddt) loaddt
 from cust_online_trans cust left outer join pos_mob_trans trans
 on trans.custno=cust.custno;



create table if not exists discoveryds.trans_aggr 
(state string,city string,category string,product string,max_amt float64,min_amt float64,sum_amt float64,approx_cnt_cust int64,states_cnt int64,mid_amt_cnt int64,high_amt_cnt int64);

truncate table discoveryds.trans_aggr;

insert into discoveryds.trans_aggr 
select state,city,category,product,max(amount) max_amt,min(amount) min_amt,sum(amount) sum_amt,
approx_count_distinct(t.custno) approx_cnt_cust,
countif(state in ('Nevada','Texas','Oregon')) as states_cnt,
countif(amount<100) mid_amt_cnt,
countif(amount>=100) high_amt_cnt
--count(case when amount<100 then 1 else 0 end) mid_amt_cnt
from (select t.txnno,c.custno,age,yearofbirth,profession,amount,category,product,city,state,spendby,net,provider,activity,t.txndt 
from curatedds.consumer_full_load c 
inner join curatedds.trans_pos_part_cluster t
on c.custno=t.custno
inner join `curatedds.trans_mobile_autopart_2023` t23
on t.txnno=t23.txnno) t
group by state,city,category,product;

